<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - loaders - OBJ loader</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		font-family: Monospace;
		background-color: #000;
		color: #fff;
		margin: 0px;
		overflow: hidden;
	}
	#info {
		color: #fff;
		position: absolute;
		top: 10px;
		width: 100%;
		text-align: center;
		z-index: 100;
		display:block;
	}
	#info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
	</style>
</head>

<body>
	<div id="info">
		<a href="http://threejs.org" target="_blank">three.js</a> - OBJLoader test
	</div>

	<script src="js/three.min.js"></script>
	<script src="js/loaders/OBJLoader.js"></script>
	<script src="js/loaders/MTLLoader.js"></script>
	<script src="js/loaders/DDSLoader.js"></script>
	<script src="js/controls/FlyControls.js"></script>
	<script src="js/Detector.js"></script>
	<script src="js/libs/stats.min.js"></script>

	<script>

	if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

	var container, stats;

	var camera, controls, scene, renderer;

	var cross;

	var clock = new THREE.Clock();

	init();
	animate();

	function init() {
		// Create container
		container = document.createElement( 'div' );
		document.body.appendChild( container );
		document.onkeydown = checkKey;

		/*	PerspectiveCamera( fov, aspect, near, far )
		*
		*	fov — Camera frustum vertical field of view.
		*	aspect — Camera frustum aspect ratio.
		*	near — Camera frustum near plane.
		*	far — Camera frustum far plane.
		*/
		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 10000 );
		camera.position.z = 0;

		// Controls
		controls = new THREE.FlyControls( camera );
		controls.movementSpeed = 100;
		controls.domElement = container;
		controls.rollSpeed = Math.PI / 12;
		controls.autoForward = false;
		controls.dragToLook = true;


		// scene
		scene = new THREE.Scene();

		var ambient = new THREE.AmbientLight( 0x404040 );
		scene.add( ambient );

		var directionalLight = new THREE.DirectionalLight( 0xffeedd );
		directionalLight.position.set( 0, 0, 1 );

		scene.add( directionalLight );

		// texture

		var manager = new THREE.LoadingManager();
		manager.onProgress = function ( item, loaded, total ) {

			console.log( item, loaded, total );

		};

		var texture = new THREE.Texture();

		var onProgress = function ( xhr ) {
			if ( xhr.lengthComputable ) {
				var percentComplete = xhr.loaded / xhr.total * 100;
				console.log( Math.round(percentComplete, 2) + '% downloaded' );
			}
		};

		var onError = function ( xhr ) {
		};


		THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );
		var mtlLoader = new THREE.MTLLoader();
		mtlLoader.setBaseUrl( 'models/' );
		mtlLoader.setPath( 'models/' );
		mtlLoader.load( 'hearc_0.mtl', function( materials ) {
			materials.preload();
			var objLoader = new THREE.OBJLoader();
			objLoader.setMaterials( materials );
			objLoader.setPath( 'models/' );
			objLoader.load( 'hearc_0.obj', function ( object ) {
				object.position.y = - 95;
				scene.add( object );
			}, onProgress, onError );
		});

		// renderer

		renderer = new THREE.WebGLRenderer();
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		stats.domElement.style.zIndex = 100;
		container.appendChild( stats.domElement );

		//
		window.addEventListener( 'resize', onWindowResize, false );

		render();
	}

	function checkKey(e) {
		var event = window.event ? window.event : e;
		if(event.keyCode == 32){
			console.log(camera.position);
		}
	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );
	}

	//

	function animate() {

		requestAnimationFrame( animate );

		render();
		stats.update();
	}

	function render() {
		var delta = clock.getDelta();

		controls.update( delta );

		renderer.render( scene, camera );
	}

	</script>

</body>
</html>

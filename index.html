<!DOCTYPE html>
<html lang="en">
<head>
    <title>Arc3D</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300' rel='stylesheet' type='text/css'>
    <link href="./arc3d.css" rel='stylesheet' type='text/css'>
</head>

<body>
    <div id="info">
        <h1>Arc3D</h1>
        <select id="select_node_a">
        </select>
        <select id="select_node_b">
        </select>
        <button onclick="selectPath()">GO !</button>
        <button onclick="stopCamera()">Stop</button>
        <input type="range" value="50" max="200" min="0" step="5" oninput="selectSpeed(this.value)" onchange="selectSpeed(this.value)">
        <!-- <button onclick="saveCameraPosition()">save camera pos</button> -->
    </div>

    <script src="threejs/three.min.js"></script>
    <script src="threejs/loaders/OBJLoader.js"></script>
    <script src="threejs/loaders/MTLLoader.js"></script>
    <script src="threejs/loaders/DDSLoader.js"></script>
    <script src="threejs/controls/FlyControls.js"></script>
    <script src="threejs/Detector.js"></script>
    <script src="threejs/libs/stats.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>

    <!-- My scrips -->
    <script src="js/Pathfinder.js"></script>
    <script src="js/CameraTracking.js"></script>

    <script>

    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

    // Model
    var m_name = 'hearc';
    var m_version = '4';
    var m_path = m_name + '_' + m_version;

    // Pathfinding
    var nodes, pathfinder, camera_tracking;
    var path = [];
    var lines = [];
    var boxes = [];
    var key_points = [];


    // THREE
	var raycaster, mouse;
    var container, stats;
    var camera, controls, scene, renderer;
    var clock = new THREE.Clock();


    // Start
    init();
    animate();


    // Request JSON Async w/ JQuery
    $.getJSON("js/nodes.json", function(json) {
        nodes = json.nodes;
        initMenu();
        pathfinder = new Pathfinder(nodes);
        var start_id = 3000;
        var goal_id = 3011;
        updatePathfinding(start_id, goal_id);
        // initNodes();
    });

    function selectSpeed(new_speed){
        camera_tracking.set_speed(new_speed);
    }

    /**
    * Initialize the menu with the nodes
    * Should be called when the nodes are initialized.
    */
    function initMenu(){
        var select_node_a = document.getElementById('select_node_a');
        var select_node_b = document.getElementById('select_node_b');
        for(i = 0; i < nodes.length; i++)
        {
            var node = nodes[i];
            if(!node.name)
            continue;
            var option_a = document.createElement("option");
            option_a.text = "" + node.name + " [" + node.id + "]";
            option_a.value = node.id;
            var option_b = option_a.cloneNode(true);
            select_node_a.options.add(option_a, node.id);
            select_node_b.options.add(option_b, node.id);
        }
    }

    function selectPath(){
        var select_node_a = document.getElementById('select_node_a');
        var select_node_b = document.getElementById('select_node_b');
        var selected_a = Number(select_node_a.options[select_node_a.selectedIndex].value);
        var selected_b = Number(select_node_b.options[select_node_b.selectedIndex].value);

        updatePathfinding(selected_a, selected_b);

        camera_tracking.start();
    }

    /**
    * Update the pathfinding.
    *  Get the new path from the Pathfinder and then calls the appropriate methods
    *
    * @param{Number} node_start_id: The first node ID
    * @param{Number} node_goal_id: The goal node ID
    */
    function updatePathfinding(node_start_id, node_goal_id) {
        path = pathfinder.get_path(node_start_id, node_goal_id);
        // initNodes();

        var curve_points = pathfinder.get_vectors_from_path(path);
        camera_tracking.set_path(curve_points);
    }

    function stopCamera(){
        camera_tracking.stop();
    }

    /**
    * DEBUG thanks js
    */
    function saveCameraPosition(){
        localStorage.cpx = camera.position.x;
        localStorage.cpy = camera.position.y;
        localStorage.cpz = camera.position.z;
        localStorage.crx = camera.rotation.x;
        localStorage.cry = camera.rotation.y;
        localStorage.crz = camera.rotation.z;
    }

    function init() {
        // Create container
        container = document.createElement( 'div' );
        document.body.appendChild( container );
        document.onkeydown = checkKey;

        //	PerspectiveCamera( fov, aspect, near, far )
        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 10000 );
        // camera.position.set(Number(localStorage.cpx), Number(localStorage.cpy), Number(localStorage.cpz));
        // camera.rotation.set(Number(localStorage.crx), Number(localStorage.cry), Number(localStorage.crz));
        camera.position.set(518.1343902256439, 179.21829815866715, -204.30850284213201);
        camera.rotation.set(-0.1076350906304018, 1.5321409768616594, 0.07200147984575293);



        // Camera tracking use for pathfinding animation
        camera_tracking = new CameraTracking(camera);

        // scene
        scene = new THREE.Scene();

        // Lights
        var ambient = new THREE.AmbientLight( 0xffffff );
        scene.add( ambient );
        var lights = [];
		lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
		lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
		lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );

		lights[ 0 ].position.set( 0, 200, 0 );
		lights[ 1 ].position.set( 100, 200, 100 );
		lights[ 2 ].position.set( - 100, - 200, - 100 );

		scene.add( lights[ 0 ] );
		scene.add( lights[ 1 ] );
		scene.add( lights[ 2 ] );

        // var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
        // directionalLight.position.set( 0, 1, 0 );
        // scene.add( directionalLight );

        var onProgress = function ( xhr ) {
            if ( xhr.lengthComputable ) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log( Math.round(percentComplete, 2) + '% downloaded' );
            }
        };

        var onError = function ( xhr ) {
        };
        // JSON LOADER
        var jsonLoader = new THREE.JSONLoader();
        models = ["walls_0", "walls_1", "walls_2", "walls_3", "ceiling_0", "ceiling_1", "ceiling_2", "stairs"];
        for(var i = 0; i < models.length; i++)
        {
            jsonLoader.load("models/multipart/" + models[i] + ".js", addModelToScene);
        }



		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setClearColor( 0xcccccc );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        // Controls
        controls = new THREE.FlyControls(camera, renderer.domElement);
        controls.movementSpeed = 100;
        controls.domElement = container;
        controls.rollSpeed = 1;
        controls.autoForward = false;
        controls.dragToLook = true;

        // Stats
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        stats.domElement.style.zIndex = 100;
        container.appendChild( stats.domElement );

		// document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        window.addEventListener( 'resize', onWindowResize, false );
        render();
    }

    function addModelToScene(geometry, materials)
    {
        delete materials[0].shininess;
        var material = new THREE.MeshLambertMaterial(materials[0]);
        mesh = new THREE.Mesh(geometry, material);
        //TODO: Find out why the model is not at its correct position
        mesh.position.y -= 100;
        scene.add(mesh);
    }

    /**
    * DEBUG : Log node object when clicked
    */
    function onDocumentMouseDown( event ) {

		event.preventDefault();

		mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObjects( boxes );

		if ( intersects.length > 0 ) {
			var node = pathfinder.get_node(Number(intersects[ 0 ].object.name));
            console.log(node);
       }
	}

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function animate() {
        requestAnimationFrame( animate );
        render();
        stats.update();
    }

    function render() {
        var delta = clock.getDelta();
        controls.update( delta );
        renderer.render( scene, camera );

        camera_tracking.update(delta);
    }

    //==========================================================================
    //                           Nodes
    //==========================================================================

    function initNodes()
    {
        // Clear scene
        while(lines.length !== 0 && boxes.length !== 0)
        {
            scene.remove(lines.pop());
            scene.remove(boxes.pop());
        }

        // Materials and Geometry
        var box_geometry = new THREE.BoxGeometry(2, 2, 2);
        var box_mat_yellow = new THREE.MeshBasicMaterial( {color: 0xffff00 } );
        var box_mat_red = new THREE.MeshBasicMaterial( {color: 0xff0000 } );
        var lin_mat_yellow = new THREE.LineBasicMaterial( {color: 0xffff00 } );
        var lin_mat_red = new THREE.LineBasicMaterial( {color: 0xff0000 } );

        nodes.forEach(function(node){
            // Add links
            node.neighbors.forEach(function(neighbor_id){
                var line_geometry = new THREE.Geometry();
                var lin_mat = lin_mat_red;
                if((path[path.indexOf(node.id) - 1] == neighbor_id) || (path[path.indexOf(neighbor_id) - 1] == node.id))
                {
                    lin_mat = lin_mat_yellow;
                }
                var neighbor = pathfinder.get_node(neighbor_id);
                line_geometry.vertices.push(
                    node.position,
                    neighbor.position
                );
                var line = new THREE.Line(line_geometry, lin_mat);
                lines.push(line);
                scene.add(line);
            });

            // Add box
            var box_mat = path.indexOf(node.id) != -1 ? box_mat_yellow : box_mat_red;
            var box_mesh = new THREE.Mesh(box_geometry, box_mat);
            box_mesh.position.copy(node.position);
            box_mesh.name = node.id;
            boxes.push(box_mesh);
            scene.add(box_mesh);
        });

        // console.log(JSON.stringify(nodes));      Can be used to have a .json output
    }

    /*
    *   Log some informations on key press
    */
    function checkKey(e) {
        var event = window.event ? window.event : e;
        if(event.keyCode == 32){
            var geometry = new THREE.BoxGeometry( 1, 1, 1 );
            var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
            var mesh = new THREE.Mesh( geometry, material );
            mesh.position.set(camera.position.x, camera.position.y, camera.position.z);
            var point = {id:key_points.length + 3000, position:{x:camera.position.x, y:camera.position.y, z:camera.position.z}, neighbors:[]};
            key_points.push(point);
            var object;
            console.log(JSON.stringify(key_points));
            // console.log(point);
            scene.add( mesh );
            initNodes();
        }
    }

    </script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <title>Arc3D</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300' rel='stylesheet' type='text/css'>
    <link href="./arc3d.css" rel='stylesheet' type='text/css'>
</head>

<body>
    <div id="info">
        <h1>Arc3D</h1>
        <select id="select_node_a">
        </select>
        <select id="select_node_b">
        </select>
        <button onclick="selectPath()">GO !</button>
        <button onclick="stopCamera()">Stop</button>
        <input type="range" value="50" max="200" min="0" step="5" oninput="selectSpeed(this.value)" onchange="selectSpeed(this.value)">
        <button onclick="geoFindMe()">Find me</button>
        <button id="control" onclick="ARC3D.switchControls()">Switch Controls</button>
    </div>

    <script src="threejs/three.min.js"></script>
    <script src="threejs/loaders/OBJLoader.js"></script>
    <script src="threejs/loaders/MTLLoader.js"></script>
    <script src="threejs/loaders/DDSLoader.js"></script>
    <script src="threejs/controls/FlyControls.js"></script>
    <script src="threejs/controls/DeviceOrientationControls.js"></script>
    <script src="threejs/Detector.js"></script>
    <script src="threejs/libs/stats.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>

    <!-- My scripts -->
    <script src="js/arc3d.js"></script>
    <script src="js/Pathfinder.js"></script>
    <script src="js/CameraTracking.js"></script>

    <script>

    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

    // Check if position is defined in GET paramters
    var current_node_id = ARC3D.getUrlParameter('node_id');
    if(current_node_id !== undefined) {
        console.log("current: " + current_node_id);
        ARC3D.isPositionDefined = true;
    }

    // nodespathflol
    var nodes, pathfinder, cameraTracking, spline;
    var path = [];
    var lines = [];
    var boxes = [];
    var key_points = [];

    //TODO: use or note. Window reflection
    var reflectionCube;
    var texture_path = 'models/textures/';

    // Accelerometer localisation
    var user_velocity = new THREE.Vector3(0.0, 0.0, 0.0);
    var user_position = new THREE.Vector3(0.0, 0.0, 0.0);

    var last_time;

    // THREE
	var raycaster, mouse;
    var container, stats;
    var camera, controls, scene, renderer;
    var clock = new THREE.Clock();




    /**
    * Request asynchronously the .json file of nodes and the init the whole program
    * It's something. ¯\_(ツ)_/¯
    */
    $.getJSON("nodes/nodes.json", function(json) {
        nodes = json.nodes;
        initMenu();
        pathfinder = new ARC3D.Pathfinder(nodes);


        // Start
        init();
        animate();
    });

    function selectSpeed(new_speed){
        cameraTracking.setSpeed(new_speed);
    }



    function deviceMotionHandler(eventData) {
        if (last_time === undefined){
            last_time = Date.now();
            return;
        }
        var now = Date.now();
        var dt = now - last_time;
        last_time = now;

        // Grab the acceleration from the results
        var a = eventData.acceleration;
        var accVec = new THREE.Vector3(a.x, a.y, a.z);
        user_velocity.add(accVec.multiplyScalar(dt));
        user_position.add(user_velocity.multiplyScalar(dt));
        console.log(user_velocity);
        console.log(user_position);
    }


    /**
    * Initialize the menu with the nodes
    * Should be called when the nodes are initialized.
    */
    function initMenu(){
        var select_node_a = document.getElementById('select_node_a');
        var select_node_b = document.getElementById('select_node_b');
        for(i = 0; i < nodes.length; i++)
        {
            var node = nodes[i];
            if(!node.name)
            continue;
            var option_a = document.createElement("option");
            option_a.text = "" + node.name + " [" + node.id + "]";
            option_a.value = node.id;
            var option_b = option_a.cloneNode(true);
            select_node_a.options.add(option_a, node.id);
            select_node_b.options.add(option_b, node.id);
        }
    }

    function selectPath(){
        var select_node_a = document.getElementById('select_node_a');
        var select_node_b = document.getElementById('select_node_b');
        var selected_a = Number(select_node_a.options[select_node_a.selectedIndex].value);
        var selected_b = Number(select_node_b.options[select_node_b.selectedIndex].value);

        updatePathfinding(selected_a, selected_b);
    }

    /**
    * Update the pathfinding.
    *  Get the new path from the Pathfinder and then calls the appropriate methods
    *
    * @param{Number} node_start_id: The first node ID
    * @param{Number} node_goal_id: The goal node ID
    */
    function updatePathfinding(node_start_id, node_goal_id) {
        path = pathfinder.getPath(node_start_id, node_goal_id);
        spline = cameraTracking.setPath(pathfinder.getPathPositions(path));
        console.log(spline.getLength());

        // Create a Tubegeometry from the spline created by the CameraTracking
        var geometry = new THREE.TubeGeometry(spline, Math.floor(spline.getLength() / 10), 2, 8, false);
        var material = new THREE.MeshPhongMaterial( {color: 0x4caf50 } );
        var mesh = new THREE.Mesh(geometry, material);
        mesh.position.y -= 20;
        scene.add(mesh);
        cameraTracking.start();
    }

    function stopCamera(){
        cameraTracking.stop();
    }

    function init() {
        // Create container
        container = document.createElement( 'div' );
        document.body.appendChild( container );
        document.onkeydown = ARC3D.keyEvent;

        //	PerspectiveCamera( fov, aspect, near, far )
        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 10000 );
        if(!ARC3D.isPositionDefined){
            camera.position.copy(ARC3D.defaultCameraPosition);
            user_position.copy(ARC3D.defaultCameraPosition);
        }else{
            camera.position.copy(pathfinder.getNodePosition(current_node_id));
            user_position.copy(pathfinder.getNodePosition(current_node_id));
        }


        var t_path = "models/textures/";
        var t_form = ".png";
        var urls = [
            t_path + 'mur-orange' + t_form, t_path + 'mur-orange' + t_form,
            t_path + 'plafond-orange' + t_form, t_path + 'couloir-sol' + t_form,
            t_path + 'mur-orange' + t_form, t_path + 'mur-orange' + t_form
        ];
        console.log(urls);
        reflectionCube = new THREE.CubeTextureLoader().load(urls);
        reflectionCube.format = THREE.RGBFormat;

        // Camera tracking use for pathfinding animation
        cameraTracking = new ARC3D.CameraTracking(camera);

        // scene
        scene = new THREE.Scene();

        // Lights
        var ambient = new THREE.AmbientLight( 0xffffff );
        scene.add( ambient );
        var lights = [];
		lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
		lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
		lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );

		lights[ 0 ].position.set( 0, 200, 0 );
		lights[ 1 ].position.set( 100, 200, 100 );
		lights[ 2 ].position.set( - 100, - 200, - 100 );

		scene.add( lights[ 0 ] );
		scene.add( lights[ 1 ] );
		scene.add( lights[ 2 ] );

        // var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
        // directionalLight.position.set( 0, 1, 0 );
        // scene.add( directionalLight );

        var onProgress = function ( xhr ) {
            if ( xhr.lengthComputable ) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log( Math.round(percentComplete, 2) + '% downloaded' );
            }
        };

        var onError = function ( xhr ) {
        };
        // JSON LOADER
        var jsonLoader = new THREE.JSONLoader();
        models = ["commerce_0", "walls_0", "walls_1", "walls_2", "walls_3", "floors", "stairs", "window_0", "window_1", "window_2"];
        for(var i = 0; i < models.length; i++)
        {
            jsonLoader.load("models/multipart/" + models[i] + ".js", addModelToScene);
        }



		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setClearColor( 0xcccccc );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        ARC3D.switchControls();

        // Stats
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        stats.domElement.style.zIndex = 100;
        container.appendChild( stats.domElement );

		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        window.addEventListener( 'resize', onWindowResize, false );

        render();
    }

    function addModelToScene(geometry, materials)
    {
        var material = new THREE.MultiMaterial(materials);
        mesh = new THREE.Mesh(geometry, material);
        mesh.position.y -= 100;
        scene.add(mesh);
    }

    /**
    * DEBUG : Log node object when clicked
    */
    function onDocumentMouseDown( event ) {

		event.preventDefault();

		mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObjects( boxes );

		if ( intersects.length > 0 ) {
			var node = pathfinder.getNode(Number(intersects[ 0 ].object.name));
            console.log(node);
       }
	}

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function animate() {
        requestAnimationFrame( animate );
        render();
        stats.update();
    }

    function render() {
        var delta = clock.getDelta();
        controls.update( delta );
        renderer.render( scene, camera );

        cameraTracking.update(delta);
    }

    </script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <title>Arc3D</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300' rel='stylesheet' type='text/css'>
    <link href="./arc3d.css" rel='stylesheet' type='text/css'>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
        <!-- Compiled and minified CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.6/css/materialize.min.css">

    <!-- Compiled and minified JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.6/js/materialize.min.js"></script>
</head>

<body>
    <div id="info">
        <select class="browser-default" id="select_node_a">
        </select>
        <select class="browser-default"  id="select_node_b">
        </select>
        <a class="waves-effect waves-light btn" onclick="selectPath()">Démarrer</a>
        <a class="waves-effect waves-light btn"  onclick="togglePause()">Pause</a>
        <a class="waves-effect waves-light btn" onclick="ARC3D.toggleFullScreen()">[]</a>

        <!-- <button onclick="changeControls()" id="change_controls" >Mobile</button> -->
        Speed:
        <input type="range" value="50" max="200" min="0" step="5" oninput="selectSpeed(this.value)" onchange="selectSpeed(this.value)">
    </div>

    <div id="left-clicker" onclick="clickLeft()">
    </div>
    <div id="right-clicker" onclick="clickRight()">
    </div>

    <script src="threejs/three.min.js"></script>
    <script src="threejs/loaders/OBJLoader.js"></script>
    <script src="threejs/loaders/MTLLoader.js"></script>
    <script src="threejs/loaders/DDSLoader.js"></script>
    <script src="threejs/controls/FlyControls.js"></script>
    <script src="threejs/controls/DeviceOrientationControls.js"></script>
    <script src="threejs/Detector.js"></script>
    <script src="threejs/libs/stats.min.js"></script>

    <!-- My scripts -->
    <script src="js/arc3d.js"></script>
    <script src="js/Pathfinder.js"></script>
    <script src="js/CameraTracking.js"></script>

    <script>

    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

    // Check if position is defined in GET paramters
    var current_node_id = ARC3D.getUrlParameter('node_id');
    if(current_node_id !== undefined) {
        console.log("current: " + current_node_id);
        ARC3D.isPositionDefined = true;
    }

    // nodespathflol
    var nodes, pathfinder, cameraTracking, spline;
    var path = [];
    var lines = [];
    var boxes = [];
    var key_points = [];

    //TODO: use or note. Window reflection
    var reflectionCube;
    var texture_path = 'models/textures/';

    // Accelerometer localisation
    var user_velocity = new THREE.Vector3(0.0, 0.0, 0.0);
    var user_position = new THREE.Vector3(0.0, 0.0, 0.0);

    var last_time;

    // THREE
	var raycaster, mouse;
    var container, stats;
    var camera, controls, scene, renderer;
    var clock = new THREE.Clock();

    THREE.DefaultLoadingManager.onProgress = function ( item, loaded, total ) {
        console.log( item, loaded, total );
    };

    /**
    * Request asynchronously the .json file of nodes, then init the whole program
    * It's something. ¯\_(ツ)_/¯
    *
    * Synchronously asynchronous
    */
    $.getJSON("nodes/nodes.json", function(json) {
        nodes = json.nodes;
        initMenu();
        pathfinder = new ARC3D.Pathfinder(nodes);

        // Start
        init();
        animate();
    });

    function clickLeft(){
        console.log("Left side clicked");
    }

    function clickRight(){
        controls.setNorth();
        console.log("Right side clicked");
    }

    function stopCamera(){
        cameraTracking.stop();
    }

    function togglePause(){
        cameraTracking.togglePause();
    }

    function changeControls(){
        var btn = document.getElementById('change_controls');
        switch(ARC3D.controlMode){
            case ARC3D.ControlModes.GYRO:
                ARC3D.setControl(ARC3D.ControlModes.FLY);
                btn.innerHTML = "Desktop";
                break;
            case ARC3D.ControlModes.FLY:
                ARC3D.setControl(ARC3D.ControlModes.GYRO);
                btn.innerHTML = "Mobile";
                break;
        }
    }

    function selectSpeed(new_speed){
        cameraTracking.setSpeed(new_speed);
    }


    /**
    * Initialize the menu with the nodes
    * Should be called when the nodes are initialized.
    */
    function initMenu(){
        if(nodes === undefined)
            console.err("ARC3D : Nodes should be defined before initMenu()");

        var select_node_a = document.getElementById('select_node_a');
        var select_node_b = document.getElementById('select_node_b');
        for(i = 0; i < nodes.length; i++)
        {
            var node = nodes[i];
            if(!node.name)
                continue;

            if (node.name.split('-')[0] == 'room'){
                var option_a = document.createElement("option");
                option_a.text = "Salle " + node.name.split('-')[1];
                option_a.value = node.id;
                var option_b = option_a.cloneNode(true);
                select_node_a.options.add(option_a, node.id);
                select_node_b.options.add(option_b, node.id);
            }
        }
    }

    function selectPath(){
        var select_node_a = document.getElementById('select_node_a');
        var select_node_b = document.getElementById('select_node_b');
        var selected_a = Number(select_node_a.options[select_node_a.selectedIndex].value);
        var selected_b = Number(select_node_b.options[select_node_b.selectedIndex].value);

        updatePathfinding(selected_a, selected_b);
    }

    /**
    * Update the pathfinding.
    *  Get the new path from the Pathfinder and then calls the appropriate methods
    *
    * @param{Number} node_start_id: The first node ID
    * @param{Number} node_goal_id: The goal node ID
    */
    function updatePathfinding(node_start_id, node_goal_id) {
        path = pathfinder.getPath(node_start_id, node_goal_id);
        spline = cameraTracking.setPath(pathfinder.getPathPositions(path));
        console.log(spline.getLength());

        // Remove old Tubegeometry if exist
        var o = scene.getObjectByName("spline");
        scene.remove(o);

        // Create a Tubegeometry from the spline created by the CameraTracking
        var geometry = new THREE.TubeGeometry(spline, Math.floor(spline.getLength() / 10), 2, 8, false);
        var material = new THREE.MeshPhongMaterial( {color: 0x4caf50 } );
        var mesh = new THREE.Mesh(geometry, material);
        mesh.name = "spline";
        mesh.position.y -= 20;
        scene.add(mesh);
        cameraTracking.start();
    }
    function init() {
        // Create container
        container = document.createElement( 'div' );
        document.body.appendChild( container );
        // document.onkeydown = ARC3D.keyEvent;

        //	PerspectiveCamera( fov, aspect, near, far )
        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 10000 );
        if(!ARC3D.isPositionDefined){
            camera.position.copy(ARC3D.defaultCameraPosition);
            user_position.copy(ARC3D.defaultCameraPosition);
        }else{
            camera.position.copy(pathfinder.getNodePosition(current_node_id));
            user_position.copy(pathfinder.getNodePosition(current_node_id));
        }


        // Load a reflection Cube for inside surfaces
        var t_path = "models/textures/";
        var t_form = ".png";
        var urls = [
            t_path + 'mur-orange' + t_form, t_path + 'mur-orange' + t_form,
            t_path + 'plafond-orange' + t_form, t_path + 'couloir-sol' + t_form,
            t_path + 'mur-orange' + t_form, t_path + 'mur-orange' + t_form
        ];
        reflectionCube = new THREE.CubeTextureLoader().load(urls);
        reflectionCube.format = THREE.RGBFormat;

        // Camera tracking use for pathfinding animation
        cameraTracking = new ARC3D.CameraTracking(camera);

        // scene
        scene = new THREE.Scene();

        // Lights
        var ambient = new THREE.AmbientLight( 0xffffff );
        scene.add( ambient );
        var lights = [];
		lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
		lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
		lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );

		lights[ 0 ].position.set( 0, 200, 0 );
		lights[ 1 ].position.set( 100, 200, 100 );
		lights[ 2 ].position.set( - 100, - 200, - 100 );

		scene.add( lights[ 0 ] );
		scene.add( lights[ 1 ] );
		scene.add( lights[ 2 ] );

        // var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
        // directionalLight.position.set( 0, 1, 0 );
        // scene.add( directionalLight );

        var onProgress = function ( xhr ) {
            if ( xhr.lengthComputable ) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log( Math.round(percentComplete, 2) + '% downloaded' );
            }
        };

        var onError = function ( xhr ) {
        };
        // JSON LOADER
        var jsonLoader = new THREE.JSONLoader();
        models = ["commerce_0", "walls_0", "walls_1", "walls_2", "walls_3", "floors", "stairs", "window_0", "window_1", "window_2"];
        for(var i = 0; i < models.length; i++)
        {
            jsonLoader.load("models/multipart/" + models[i] + ".js", addModelToScene);
        }


        // TODO: Remove this. Used for debug. To check which node is which one. gud english hear
		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

        // Renderer
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setClearColor( 0xcccccc );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        // Set control mode
        if (window.DeviceOrientationEvent) {
            // Listen for the event and handle DeviceOrientationEvent object
            ARC3D.setControl(ARC3D.ControlModes.GYRO);
        }else{
            ARC3D.setControl(ARC3D.ControlModes.FLY);
        }

        // Stats
        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        stats.domElement.style.zIndex = 100;
        // container.appendChild( stats.domElement );

		// document.addEventListener( 'mousedown', onDocumentMouseDown, false );
        window.addEventListener( 'resize', onWindowResize, false );

        render();
    }

    function addModelToScene(geometry, materials)
    {
        var material = new THREE.MultiMaterial(materials);
        mesh = new THREE.Mesh(geometry, material);
        mesh.position.y -= 100;
        scene.add(mesh);
    }

    /**
    * DEBUG : Log node object when clicked
    */
    function onDocumentMouseDown( event ) {

		event.preventDefault();

		mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObjects( boxes );

		if ( intersects.length > 0 ) {
			var node = pathfinder.getNode(Number(intersects[ 0 ].object.name));
            console.log(node);
       }
	}

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    function animate() {
        requestAnimationFrame( animate );
        render();
        stats.update();
    }

    function render() {
        var delta = clock.getDelta();
        controls.update( delta );
        renderer.render( scene, camera );

        cameraTracking.update(delta);
    }

    </script>

</body>
</html>
